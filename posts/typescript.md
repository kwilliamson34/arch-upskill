---
title: "Proficiency in Typescript"
subtitle: "Setup, use, and understanding the black magic of autogenerated tsconfig.json"
date: "2024-08-02"
status: "In Progress"
---

### Background

The goal of TypeScript is to be a static typechecker for JavaScript programs - in other words, a tool that runs before your code runs (static) and ensures that the types of the program are correct (typechecked).

Benefits of TypeScript

- Catch errors early in your editor (ECMAScript runtime errors, logical errors, typos, etc)
- Develop common language; describe your data; create documentation / an API surface; clearer communication between parts of your program
- Powerful editor integration: code completion; error fix suggestions; re-organize suggestions; navigation feautres; references

Voted 2nd most loved programming language in the Stack Overflow 2020 Developer survey

A reader who completes the [walkthrough](https://www.typescriptlang.org/docs/handbook/intro.html) should be able to:

- Read and understand commonly-used TypeScript syntax and patterns
- Explain the effects of important compiler options
- Correctly predict type system behavior in most cases

### tsc, the TypeScript compiler

It can be used from command line. It compiles or transforms it into a plain JavaScript file. It can be used to test the runtime behavior locally and get ahead of errors.

Most TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased. Remember: Type annotations never change the runtime behavior of your program.

### Relationship to JS

By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code. That’s how TypeScript knows that helloWorld is a string in the above example.

It’s important to remember that TypeScript uses the same runtime as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs.

You may have written JavaScript in Visual Studio Code, and had editor auto-completion. Visual Studio Code uses TypeScript under the hood to make it easier to work with JavaScript.

Objects can make it difficult to infer types; Use interfaces. Additionally, of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural typing”. Shape-matching only requires a subset of the object’s fields to match.

### Relationship to OOP

TypeScript’s type system offers many of the same benefits, such as better code completion, earlier detection of errors, and clearer communication between parts of your program.

TypeScript supports many common patterns such as implementing interfaces, inheritance, and static methods.

In C# or Java, any given value or object has one exact type - either null, a primitive, or a known class type. We can call methods like value.GetType() or value.getClass() to query the exact type at runtime. The definition of this type will reside in a class somewhere with some name, and we can’t use two classes with similar shapes in lieu of each other unless there’s an explicit inheritance relationship or commonly-implemented interface.

These aspects describe a reified, nominal type system. The types we wrote in the code are present at runtime, and the types are related via their declarations, not their structures.

In TypeScript, it’s better to think of a type as a set of values that share something in common. Because types are just sets, a particular value can belong to many sets at the same time. **In TypeScript, objects are not of a single exact type.**

### Relationship to Functional Programming

[TODO](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html)

### tsconfig.json

Blew my mind that on creation of an empty tsconfig.json file in my next project, it populated itself. How did it work?

The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project.

Depending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at github.com/tsconfig/bases. These are tsconfig.json files which your project extends from which simplifies your tsconfig.json by handling the runtime support.

In Next, you can Run next dev and next build to automatically install the necessary dependencies and add a tsconfig.json file with the recommended config options. Somehow, without running those commands, but just by creating the file, the framework or editor picked it up and populated it. Note I already had some intellisense extensions installed (ES7+ React, HTML CSS Support, Prettier).

TODO: Next.js includes a custom [TypeScript plugin and type checker](https://nextjs.org/docs/app/building-your-application/configuring/typescript#typescript-plugin), which VSCode and other code editors can use for advanced type-checking and auto-completion.

### Composing types

With TypeScript, you can create complex types by combining simple ones. There are two popular ways to do so: with unions, and with generics.

### Gotchas

`number` is for numbers like 42. JavaScript does not have a special runtime value for integers, so there’s no equivalent to int or float - everything is simply `number`.

TypeScript also has a special type, `any`, that you can use whenever you don’t want a particular value to cause typechecking errors. But, any isn’t type-checked. Use the compiler flag `noImplicitAny` to flag any implicit any as an error.

With `strictNullChecks` off, values that might be null or undefined can still be accessed normally, and the values null and undefined can be assigned to a property of any type. This is similar to how languages without null checks (e.g. C#, Java) behave. The lack of checking for these values tends to be a major source of bugs; **we always recommend people turn strictNullChecks on** if it’s practical to do so in their codebase.

The type of an initialized variable can be specified, but you don't have to; the type of a variable is inferred based on the type of its initializer.

A function can be applied to different argument types if you leave it anonymous. When a function appears in a place where TypeScript can determine how it’s going to be called, the parameters of that function are automatically given types. This process is called contextual typing because the context that the function occurred within informs what type it should have.

Some syntax examples

- Arrays: `number[]` or `Array<number>`
- Objects: `let person: Person = {...};`
- Args: `function greet(person: Person) {...}`
- Objects as args: `function printName(obj: { first: string; last?: string }) {...}`
- Narrowing: `function printId(id: number | string) { if (typeof id === "string") {...} ...}`
- Type alias: `type ID = number | string;`
- Type assertion/coercion: `const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;`
- Literal types: `type alignment: "left" | "right" | "center"`; different from Enums

### Differences Between Type Aliases and Interfaces

Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.

### Differences between Literal types and Enums

Enums are real objects that exist at runtime.

Literal types are a type-level addition to JS.

Enums are a feature added to JavaScript by TypeScript which allows for describing a value which could be one of a set of possible named constants. Unlike most TypeScript features, this is not a type-level addition to JavaScript but something added to the language and runtime. Because of this, it’s a feature which you should know exists, but maybe hold off on using unless you are sure. You can read more about enums in the [Enum reference page](https://www.typescriptlang.org/docs/handbook/enums.html).

```
enum LogLevel {
  ERROR,
  WARN,
  INFO,
  DEBUG,
}
```

This is equivalent to:
type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';

```
type LogLevelStrings = keyof typeof LogLevel;
```

In modern TypeScript, you may not need an enum when an object with as const could suffice:

```
const enum EDirection {
Up,
Down,
Left,
Right,
}

const ODirection = {
Up: 0,
Down: 1,
Left: 2,
Right: 3,
} as const;
```

### Configuring in a project

[NextJS Config Guide](https://nextjs.org/docs/pages/building-your-application/configuring/typescript)

NextJS comes with built-in TypeScript support for automatically installing the necessary packages and configuring the proper settings.

create-next-app now ships with TypeScript by default.

Adding to an existing project:

- For getStaticProps, getStaticPaths, and getServerSideProps, you can use the { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'
- For API responses, you can use { NextApiRequest, NextApiResponse } from 'next'
- Since v10.2.1 Next.js supports incremental type checking when enabled in your tsconfig.json, this can help speed up type checking in larger applications.
- Next.js fails your production build (next build) when TypeScript errors are present in your project. If you'd like Next.js to dangerously produce production code even when your application has errors, you can disable the built-in type checking step in `next.config.js`. If disabled, be sure you are running type checks as part of your build or deploy process, otherwise this can be very dangerous.
- When you need to declare custom types, you might be tempted to modify next-env.d.ts. However, this file is automatically generated, so any changes you make will be overwritten. Instead, you should create a new file, let's call it new-types.d.ts, and reference it in your tsconfig.json.

### More on functions

[TODO](https://www.typescriptlang.org/docs/handbook/2/functions.html)

### Type manipulation

[TODO](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html)

### Classes and Modules

[TODO](https://www.typescriptlang.org/docs/handbook/2/classes.html)

### Newer versions

TODO
Good to know: satisfies was added to TypeScript in [4.9](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html). We recommend upgrading to the latest version of TypeScript.
